# 日志系统使用说明

## 概述

重构后的日志系统采用职责分离设计，提供两个独立的日志组件：
- **ApiLogger**: 专注于HTTP协议层面的API调用日志记录
- **LogTracer**: 专注于业务逻辑层面的方法调用和操作追踪

## 核心组件

### 1. ApiLogger (HTTP层面日志记录器)
- **位置**: `com.dailydiscover.common.util.ApiLogger`
- **职责**: HTTP协议层面的日志记录
- **特性**:
  - 统一的HTTP日志格式：`🌐 HTTP API调用 | 接口描述 | 时间戳 | URL | 方法 | 客户端 | 状态码 | 状态 | 响应 | 耗时`
  - 支持成功和异常两种日志类型
  - 自动获取客户端IP地址和HTTP状态码
  - 简化版响应内容记录（限制长度）

### 2. LogTracer (业务层面日志追踪器)
- **位置**: `com.dailydiscover.common.util.LogTracer`
- **职责**: 业务逻辑层面的日志追踪
- **特性**:
  - 业务方法追踪：`📋 业务方法追踪 | 位置 | 方法 | 入参 | 出参`
  - 数据库查询追踪：`🗃️ 数据库查询 | 位置 | SQL | 参数 | 结果`
  - 业务API调用追踪：`💼 业务API调用 | 位置 | API | 数据`
  - 业务操作追踪：`💼 业务操作 | 位置 | 操作 | 详情`
  - 业务异常追踪：`❌ 业务异常追踪 | 位置 | 异常类型 | 异常信息`
  - 业务性能追踪：`⏱️ 业务性能追踪 | 位置 | 操作 | 耗时 | 级别`

### 3. ApiLogAspect (AOP切面)
- **位置**: `com.dailydiscover.common.aspect.ApiLogAspect`
- **功能**: 自动拦截Controller方法并记录HTTP层面日志
- **拦截范围**:
  - 所有标记了`@ApiLog`注解的方法
  - 所有Controller包下的方法（`com.dailydiscover..controller..*.*(..)`）

### 4. ApiLogConfig (配置类)
- **位置**: `com.dailydiscover.common.config.ApiLogConfig`
- **功能**: 提供灵活的日志配置选项
- **配置项**:
  - `api.log.enabled`: 是否启用API日志（默认：true）
  - `api.log.excludePackages`: 排除的包路径（逗号分隔）
  - `api.log.excludeClasses`: 排除的类名（逗号分隔）
  - `api.log.excludeMethods`: 排除的方法名（逗号分隔）

## 快速开始

### 1. HTTP层面日志（自动记录）

无需任何配置，ApiLogger会自动拦截所有Controller方法记录HTTP层面信息：

```java
@RestController
@RequestMapping("/api/user")
public class UserController {
    
    @GetMapping("/info")
    public Result<UserInfo> getUserInfo() {
        // 业务逻辑
        return Result.success(userInfo);
    }
}
```

HTTP日志输出示例：
```
🌐 HTTP API调用 | UserController.getUserInfo | 2024-12-25 10:30:15 | URL: http://localhost:8080/api/user/info | 方法: GET | 客户端: 127.0.0.1 | 状态码: 200 | 状态: 成功 | 响应: Result{code=0, data=UserInfo{...}, message=null} | 耗时: 45ms
```

### 2. 业务层面日志（手动调用）

在业务方法中使用LogTracer记录业务层面的详细信息：

```java
@Service
public class UserService {
    
    public UserInfo getUserInfo(Long userId) {
        long startTime = System.currentTimeMillis();
        
        // 记录业务方法调用
        LogTracer.traceBusinessMethod("getUserInfo", userId, null);
        
        try {
            // 数据库查询
            UserInfo user = userRepository.findById(userId);
            LogTracer.traceDatabaseQuery("SELECT * FROM users WHERE id = ?", userId, user);
            
            // 记录业务操作
            LogTracer.traceBusinessOperation("获取用户信息", user);
            
            // 记录性能
            LogTracer.traceBusinessPerformance("获取用户信息", startTime);
            
            return user;
        } catch (Exception e) {
            // 记录业务异常
            LogTracer.traceBusinessException(e);
            throw e;
        }
    }
}
```

业务日志输出示例：
```
📋 业务方法追踪 | 位置: com.dailydiscover.service.UserService.getUserInfo(UserService.java:25) | 方法: getUserInfo | 入参: 123 | 出参: UserInfo{...}
🗃️  数据库查询 | 位置: com.dailydiscover.service.UserService.getUserInfo(UserService.java:30) | SQL: SELECT * FROM users WHERE id = ? | 参数: 123 | 结果: UserInfo{...}
💼 业务操作 | 位置: com.dailydiscover.service.UserService.getUserInfo(UserService.java:33) | 操作: 获取用户信息 | 详情: UserInfo{...}
⏱️  业务性能追踪 | 位置: com.dailydiscover.service.UserService.getUserInfo(UserService.java:36) | 操作: 获取用户信息 | 耗时: 45ms | 级别: ⚡ 快速
```

### 3. 使用@ApiLog注解自定义HTTP日志描述

```java
@ApiLog("获取用户信息")
@GetMapping("/info")
public Result<UserInfo> getUserInfo() {
    // 业务逻辑
    return Result.success(userInfo);
}
```

自定义HTTP日志输出示例：
```
🌐 HTTP API调用 | 获取用户信息 | 2024-12-25 10:30:15 | URL: http://localhost:8080/api/user/info | 方法: GET | 客户端: 127.0.0.1 | 状态码: 200 | 状态: 成功 | 响应: Result{code=0, data=UserInfo{...}, message=null} | 耗时: 45ms
```

### 4. 异常日志记录

当接口抛出异常时，系统会自动记录HTTP层面异常信息：

```java
@GetMapping("/info")
public Result<UserInfo> getUserInfo() {
    if (userNotFound) {
        throw new BusinessException("用户不存在");
    }
    return Result.success(userInfo);
}
```

HTTP异常日志输出示例：
```
❌ HTTP API异常 | UserController.getUserInfo | 2024-12-25 10:30:15 | URL: http://localhost:8080/api/user/info | 方法: GET | 客户端: 127.0.0.1 | 异常: 用户不存在 | 耗时: 12ms
```

## 配置说明

### 1. 日志级别配置

在`application.yml`中配置不同组件的日志级别：

```yaml
logging:
  level:
    # HTTP层面日志组件
    com.dailydiscover.common.util.ApiLogger: INFO
    com.dailydiscover.common.aspect.ApiLogAspect: INFO
    
    # 业务层面日志组件
    com.dailydiscover.common.util.LogTracer: INFO
```

### 2. 自定义配置

在`application.yml`中配置HTTP日志相关参数：

```yaml
daily-discover:
  api-log:
    # 是否启用HTTP API日志（默认：true）
    enabled: true
    # 是否记录HTTP请求参数（默认：true）
    log-request: true
    # 是否记录HTTP响应内容（默认：true）
    log-response: true
    # HTTP响应内容最大长度（默认：1000）
    max-response-length: 1000
    # 是否记录HTTP异常堆栈（默认：true）
    log-exception-stack: true
```

### 3. LogTracer配置

LogTracer无需额外配置，直接通过方法调用即可使用。支持以下配置项（通过方法参数控制）：

- **性能级别阈值**：通过`traceBusinessPerformance`方法的性能级别判断
- **日志详细程度**：通过是否调用相应方法控制
- **异常记录深度**：通过`traceBusinessException`方法参数控制

### 4. 排除配置示例

在`application.yml`中配置：

```yaml
api:
  log:
    enabled: true  # 是否启用API日志
    exclude-packages: "com.dailydiscover.user.controller.internal"  # 排除的包路径
    exclude-classes: "HealthCheckController"  # 排除的类名
    exclude-methods: "healthCheck"  # 排除的方法名
```

### 配置项详解

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `api.log.enabled` | boolean | true | 是否启用API日志功能 |
| `api.log.excludePackages` | String | "" | 需要排除的包路径，多个用逗号分隔 |
| `api.log.excludeClasses` | String | "" | 需要排除的类名，多个用逗号分隔 |
| `api.log.excludeMethods` | String | "" | 需要排除的方法名，多个用逗号分隔 |

## 日志格式说明

### 1. HTTP层面日志格式（ApiLogger）

#### 正常HTTP请求日志格式
```
🌐 HTTP API调用 | [接口描述] | [时间] | URL: [请求URL] | 方法: [HTTP方法] | 客户端: [客户端IP] | 状态码: [HTTP状态码] | 状态: [成功/失败] | 响应: [响应内容] | 耗时: [耗时ms]
```

#### HTTP异常请求日志格式
```
❌ HTTP API异常 | [接口描述] | [时间] | URL: [请求URL] | 方法: [HTTP方法] | 客户端: [客户端IP] | 异常: [异常信息] | 耗时: [耗时ms]
```

### 2. 业务层面日志格式（LogTracer）

#### 业务方法追踪日志格式
```
📋 业务方法追踪 | 位置: [方法位置] | 方法: [方法名] | 入参: [入参详情] | 出参: [出参详情]
```

#### 数据库查询日志格式
```
🗃️  数据库查询 | 位置: [方法位置] | SQL: [SQL语句] | 参数: [参数详情] | 结果: [查询结果]
```

#### 业务操作日志格式
```
💼 业务操作 | 位置: [方法位置] | 操作: [操作描述] | 详情: [操作详情]
```

#### 业务异常日志格式
```
🚨 业务异常 | 位置: [方法位置] | 异常: [异常信息] | 堆栈: [异常堆栈]
```

#### 业务性能追踪日志格式
```
⏱️  业务性能追踪 | 位置: [方法位置] | 操作: [操作描述] | 耗时: [耗时ms] | 级别: [⚡ 快速/🐢 正常/🐌 缓慢]
```

### 3. 日志格式特点

- **表情符号标识**：每个日志类型都有独特的表情符号，便于快速识别
- **结构化信息**：使用竖线分隔不同信息段，便于日志解析
- **位置信息**：包含完整的类名、方法名和行号信息
- **性能分级**：性能日志自动分级，便于性能监控

## 高级用法

### 1. HTTP层面日志高级用法

#### 自定义HTTP日志处理器

可以继承`ApiLogger`并重写相关方法来自定义HTTP日志处理逻辑：

```java
@Component
public class CustomApiLogger extends ApiLogger {
    
    @Override
    public void logHttpApiCall(String apiDescription, String url, String method, 
                              String clientIp, int statusCode, Object response, long executionTime) {
        // 自定义HTTP日志处理逻辑
        super.logHttpApiCall(apiDescription, url, method, clientIp, statusCode, response, executionTime);
        
        // 发送到HTTP监控系统
        sendToHttpMonitoringSystem(apiDescription, statusCode, executionTime);
    }
}
```

#### HTTP异步日志处理

对于高并发场景，可以配置HTTP异步日志处理：

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean("httpApiLogExecutor")
    public Executor httpApiLogExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("http-api-log-");
        executor.initialize();
        return executor;
    }
}
```

### 2. 业务层面日志高级用法

#### 业务日志上下文管理

使用`ThreadLocal`管理业务日志上下文，实现跨方法调用链追踪：

```java
@Service
public class OrderService {
    
    public void createOrder(OrderRequest request) {
        // 开始业务追踪
        LogTracer.traceBusinessMethod("createOrder", request, null);
        
        try {
            // 验证用户
            validateUser(request.getUserId());
            
            // 检查库存
            checkInventory(request.getItems());
            
            // 创建订单
            Order order = createOrderInternal(request);
            
            // 记录业务操作
            LogTracer.traceBusinessOperation("创建订单成功", order);
            
        } catch (Exception e) {
            // 记录业务异常
            LogTracer.traceBusinessException(e);
            throw e;
        }
    }
    
    private void validateUser(Long userId) {
        LogTracer.traceBusinessMethod("validateUser", userId, null);
        // 验证逻辑
    }
    
    private void checkInventory(List<OrderItem> items) {
        LogTracer.traceBusinessMethod("checkInventory", items, null);
        // 库存检查逻辑
    }
}
```

#### 业务性能监控集成

将LogTracer与性能监控系统集成：

```java
@Service
public class PerformanceMonitoringService {
    
    public void monitorBusinessPerformance(String operation, long startTime) {
        long executionTime = System.currentTimeMillis() - startTime;
        
        // 记录业务性能
        LogTracer.traceBusinessPerformance(operation, startTime);
        
        // 发送到性能监控系统
        sendToPerformanceSystem(operation, executionTime);
    }
}
```

### 3. 日志过滤

可以通过配置排除某些HTTP接口的日志记录：

```yaml
daily-discover:
  api-log:
    exclude-patterns:
      - /actuator/**
      - /health/**
      - /swagger-ui/**
```

### 4. 自定义排除规则

通过配置文件灵活控制日志记录范围：

```yaml
api:
  log:
    enabled: true
    exclude-packages: "com.dailydiscover.internal,com.dailydiscover.monitor"
    exclude-classes: "HealthController,MonitorController"
    exclude-methods: "ping,health"
```

### 5. 客户端IP获取

系统会自动从以下HTTP头中获取客户端真实IP：
- `X-Forwarded-For`
- `Proxy-Client-IP`
- `WL-Proxy-Client-IP`
- `HTTP_CLIENT_IP`
- `HTTP_X_FORWARDED_FOR`

如果以上头信息不存在，则使用`request.getRemoteAddr()`获取IP。

## 最佳实践

### 1. 职责分离原则

#### HTTP层面日志（ApiLogger）
- **自动记录**：所有Controller方法自动记录HTTP层面信息
- **专注HTTP**：只记录URL、方法、状态码、响应内容等HTTP协议信息
- **响应内容简化**：使用`formatResponse`方法简化响应内容，避免日志过大
- **异常处理**：自动记录HTTP层面的异常信息

#### 业务层面日志（LogTracer）
- **手动调用**：在业务方法中根据需要手动调用
- **业务追踪**：记录方法调用、数据库操作、业务操作等
- **性能监控**：记录业务方法执行时间，自动分级
- **异常追踪**：记录业务层面的异常信息

### 2. 接口描述规范

- **HTTP层面**：使用有意义的接口描述，便于日志分析
- **业务层面**：使用"动词+名词"的格式描述业务操作
- **避免重复**：HTTP日志和业务日志描述应互补而非重复

### 3. 性能监控

- **HTTP层面**：关注耗时超过100ms的接口
- **业务层面**：根据性能级别（快速/正常/缓慢）进行监控
- **定期分析**：定期分析日志中的性能数据
- **响应长度**：设置合理的响应内容长度限制（默认100字符）

### 4. 安全考虑

- **敏感信息**：密码、token等敏感信息不应记录在日志中
- **脱敏处理**：对敏感字段进行脱敏处理
- **日志清理**：定期清理日志文件
- **权限控制**：确保日志访问权限受控

### 5. 日志级别管理

- **生产环境**：建议使用INFO级别
- **开发环境**：可以使用DEBUG级别
- **详细程度**：根据业务需求调整日志详细程度
- **组件分离**：可单独配置ApiLogger和LogTracer的日志级别

## 故障排除

### 1. HTTP层面日志未记录

**问题现象**：接口调用但HTTP日志未记录

**可能原因**：
- ApiLogger日志级别配置不正确
- 接口被排除配置过滤
- ApiLogAspect未正确加载
- formatResponse方法调用异常

**解决方案**：
1. 检查`application.yml`中的ApiLogger日志级别配置
2. 确认接口路径不在排除列表中
3. 检查Spring Boot启动日志确认Aspect加载
4. 验证formatResponse方法是否正常调用

### 2. 业务层面日志未记录

**问题现象**：业务方法调用但LogTracer日志未记录

**可能原因**：
- LogTracer日志级别配置不正确
- 业务方法中未调用LogTracer方法
- 方法调用位置不正确

**解决方案**：
1. 检查`application.yml`中的LogTracer日志级别配置
2. 确认业务方法中正确调用了LogTracer相关方法
3. 检查方法调用位置和参数是否正确

### 3. 响应内容过长

**问题现象**：日志文件过大，响应内容被截断

**解决方案**：
1. 调整`max-response-length`配置
2. formatResponse方法已自动限制响应内容长度（100字符）
3. 对大型响应对象进行自定义格式化
4. 考虑只记录关键响应字段

### 4. 客户端IP显示不正确

**问题现象**：客户端IP显示为代理服务器IP

**解决方案**：
1. 检查反向代理配置
2. 确认X-Forwarded-For头正确传递
3. 调整IP获取策略

### 5. 性能日志级别判断不准确

**问题现象**：性能级别判断与预期不符

**解决方案**：
1. 检查LogTracer.traceBusinessPerformance方法中的阈值设置
2. 根据业务需求调整性能级别判断标准
3. 确认startTime参数传递正确

### 6. 性能影响

如果发现日志记录影响性能，可以考虑：
1. 排除高频调用的接口
2. 使用异步日志记录（需要额外配置）

## 版本历史

| 版本 | 日期 | 描述 |
|------|------|------|
| 2.0.0 | 2024-12-25 | **重构版本**：职责分离设计，ApiLogger专注HTTP层面，LogTracer专注业务层面 |
| 1.0.0 | 2024-12-25 | 初始版本，支持基本API日志功能 |

### 2.0.0 版本主要变更

#### 新增功能
- **职责分离**：明确区分HTTP层面日志和业务层面日志
- **LogTracer组件**：新增业务日志追踪工具类
- **表情符号标识**：为不同日志类型添加独特表情符号
- **性能分级**：业务性能日志自动分级（快速/正常/缓慢）

#### 重构优化
- **ApiLogger重构**：专注HTTP协议层面日志记录
- **方法重命名**：明确区分HTTP和业务相关方法
- **响应内容简化**：formatResponse方法自动限制长度
- **日志格式优化**：结构化信息，便于日志解析

#### 使用建议
- **HTTP层面**：使用ApiLogger自动记录Controller方法
- **业务层面**：在Service方法中手动调用LogTracer
- **职责明确**：避免功能重复，保持职责单一

## 相关文件

- `ApiLogger.java` - 核心日志记录器
- `ApiLogAspect.java` - AOP切面实现
- `ApiLogConfig.java` - 配置类
- `ApiLog.java` - 自定义注解

---

*最后更新: 2024-12-25*